# RSA 密码体制

## RSA 密码体制

独立选取两个大素数$p$和$q$(各 100~200 位十进制数字),计算
$$n=p\times q$$
其欧拉函数值为
$$\varphi(n)=(p-1)(q-1)$$
随机选一整数$e$,$1\le e<\varphi(n)$,$(\varphi(n),e)=1$.因而在模$\varphi(n)$下,$e$有逆元
$$d=e^{-1}\ mod\ \varphi(n)$$
取公钥为$n$,$e$.密钥为$d$($p$,$q$不再需要,可以销毁).
加密:将明文分组,各组在$mod\ n$下,可唯一地表示出来(以二元数字表示,选$2$的最大幂小于$n$).可用明文集为
$$A_z=\lbrace m:1\le m< n,(m,n)=1\rbrace$$
注意,$(m,n)\ne1$是很危险的.$m\in A_z$的概率
$$\frac{\varphi(n)}{n}=\frac{(p-1)(q-1)}{pq}=1-\frac{1}{p}-\frac{1}{q}+\frac{1}{pq}\rightarrow 1$$
密文
$$c=m^e\ mod\ n$$
解密:
$$m=c^d\ mod\ n$$
证明:$c^d=(m^e)^d=m^(de)$,因为$de\equiv 1\ mod\varphi(n)$而有$de\equiv q\varphi(n)+1$.由欧拉定理,$(m,n)=1$意味$m^{\varphi(n)}\equiv 1\ mod\ n$,故有
$$c^d=m^{de}=m^{q\varphi(n)+1}=m\cdot m^{q\varphi(n)}=m\cdot 1=m\ mod\ n$$
陷门函数:$Z=(p,q,d)$

**例** 选$p=47,q=71$,则$n=p\times q=3337,\varphi(n)=46\times 70=3220$.若选$e=79$,可计算$d=e^{-1}(mod\ 3220)=1019$.公开$n=3337$和$e=79$.密钥$d=1019$.销毁$p,q$.
令$m=688\ 232\ 687\ 966\ 668\ 3$,分组得$m_1=688,m_2=232,m_3=687,m_4=966,m_5=668,m_6=3$.$m_1$的加密为$(688)^{79}(mod\ 3337)=1570=c_1$.同样,可计算出其他各组密文.得到密文$c=1570\ 2756\ 2714\ 2423\ 158$.

第一组密文的解密为$(1570)^{1019}\ mod\ 3337=688=m_1$.类似地可解出其他各组密文.

RSA 加密实质上是一种$Z_n\rightarrow Z_n$上的单表代换.给定$n=pq$和合法明文$m\in Z_n$,其相应密文$c=m^e\ mod\ n\in Z_n$.对于$m\ne m^{'}$,必有$c\ne c^{'}$.$Z_n$中任一元素($0,p,q$除外)是一个明文,但它也是与某个明文相对应的一个密文.因此,RSA 是$Z_n\rightarrow Z_n$的一种单表代换密码,关键在于$n$极大时在不知道陷门信息下极难确定这种对应关系,而用模指数算法又易于实现一种给定的代换.正是因为这种对应性,使 RSA 不仅可以用于加密,也可以用于数字签名.

## RSA 的安全性

### 1.分解模数$n$

在理论上,RSA 的安全性取决于模$n$分解的困难性,但数学上至今还未证明分解模就是攻击 RSA 的最佳方法,也未证明分解大整数就是 NP 问题,可能有尚未发现的多项式时间算法.人们完全可以设想有另外的途径破译 RSA,如求解密指数$d$或找到$(p-1)(q-1)$等.但这些途径都不比分解$n$更容易.甚至有文献曾揭示,从 RSA 加密的密文恢复某些位的困难性也和恢复整组明文一样困难.

从$n$若能求出$\varphi(n)$,则可求得$p,q$,因为
$$n-\varphi(n)+1=pq-(p-1)(q-1)+1=p+q$$
而
$$\sqrt{(p+q)^2-4n}=p-q$$
但已经证明,求$\varphi(n)$的困难性等价于分解$n$的困难性.

从$n$求$d$也等价于分解$n$.

### 2.迭代攻击法

给定一 RSA 的参数为$(n,e,c)=(35,17,3)$,可由$c_0=c=3$计算$c_1=3^{17}=33\ mod\ 35$.再由$c_1$计算$c_2=c_1^{17}=3\ mod\ 35$,从而得到明文$m=c_1=33\ mod\ 35$.一般对明文$m$加密多次,直到再出现$m$为止.当$p-1$和$q-1$中含有大素数因子,且$n$足够大时,这种攻击法成功的概率趋于$0$.

### 3.选择密文攻击

攻击者收集用户 A 以公钥$e$加密的密文$c=m^e\ mod\ n$,并想分析出明文$m$.选随机数$r < n$,计算$c_1=r^e\ mod\ n$,这意味$r=c_1^d\ mod\ n$.计算$c_2=c_1\times c\ mod\ n$.令$t=r^{-1}\ mod\ n$,则$t=c_1^{-d}\ mod\ n$

如果攻击者请 A 对消息$c_2$进行解密,得到$s=c_2^d\ mod\ n$.攻击者计算$ts\ mod\ n=c_1^{-d}\times c_2^{d}\ mod\ n=c_1^{-d}\times c_1^{d}\times c^d\ mod\ n=c^d\ mod\ n=m$,得到了明文.

### 4.公用模攻击

若很多人共用同一模数$n$,各自选择不同的$e$和$d$,这样实现当然简单,但是不安全.若明文以两个不同的密钥加密,在共用同一个模下,若两个密钥互素(一般如此),则可用任一密钥恢复明文.

设$e_1$和$e_2$是两个互素的不同密钥,共用模为$n$,对同一明文$m$加密得$c_1=m^{e_1}\ mod\ n,c_2=m^{e_2}\ mod\ n$.分析者知道$n,e_1,e_2,c_1$和$c_2$.因为$(e_1,e_2)=1$,所以有$r\cdot e_1+s\cdot e_2=1$.假定$r$为负数,由 Euclidean 算法可计算
$$(c_1^{-1})^{-r}\cdot c_2^s=m\ mod\ n$$

### 5.低加密指数攻击

采用小的$e$可以加快加密和验证签名的速度,且所需的储存密钥空间小,但若加密密钥$e$选择得太小,则容易受到攻击.

令网络中的 3 个用户的加密密钥$e$均选$3$,而有不同的模$n_1,n_2,n_3$.若一个用户将消息$m$传给 3 个用户的密文分别为
$$c_1=m^3\ mod\ n_1\ \ \ \ m < n_1$$
$$c_2=m^3\ mod\ n_2\ \ \ \ m < n_2$$
$$c_3=m^3\ mod\ n_3\ \ \ \ m < n_3$$
一般选$n_1,n_2,n_3$互素(否则,可求出公因子而降低安全性),利用中国剩余定理,可从$c_1,c_2,c_3$求出
$$c=m^3\ mod(n_1n_2n_3)$$
由$m < n_1,m < n_2,m < n_3$,可得$m^3 < n_1\cdot n_2\cdot n_3$,故有$\sqrt[3]{c}=m$.

为抗击这种攻击$e$必须选得足够大.一般$e$选为 16 位素数时,即可兼顾快速加密,又可防止这类攻击.

### 6.定时攻击法

利用测定 RSA 解密所进行的模指数运算的时间来估计解密指数$d$,然后再精确定出$d$的取值.另外还可以采用盲化技术,即首先将数据进行盲化运算,再进行加密运算,而后做去盲运算.这样做虽然不能使解密运算时间保持不变,但计算时间被随机化而难于推测解密所进行的指数运算的时间.

### 7.消息隐匿问题

对明文$m,0\le m\le n-1$,采用 RSA 体制加密,可能出现$m^e=m\ mod\ n$,致使消息暴露.这是明文在 RSA 加密下的不动点.总有一些不动点,如$m=0,1$和$n-1$.一般有$[1+gcd(e-1,p-1)]\cdot[1+gcd(e-1,q-1)]$个不动点.由于$e-1,p-1$和$q-1$都是偶数,所以不动点至少为$9$个.一般来说,不动点个数相当少,可以忽略不计.
